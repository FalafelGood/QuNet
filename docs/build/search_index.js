var documenterSearchIndex = {"docs":
[{"location":"#QuNet","page":"Home","title":"QuNet","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuNet","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QuNet]","category":"page"},{"location":"#MetaGraphs.MetaDiGraph-Tuple{BasicNetwork}","page":"Home","title":"MetaGraphs.MetaDiGraph","text":"Convert a QNetwork object to a directed MetaGraphs in Julia LightGraphs. Directed MetaGraphs are used over weighted di-graphs is because they are more performant at removing edges.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.BasicChannel","page":"Home","title":"QuNet.BasicChannel","text":"Default Channel type\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.BasicNetwork","page":"Home","title":"QuNet.BasicNetwork","text":"Basic QNetwork structure. Although it is mutable, removing nodes and channels should be avoided. Large manipulations are done by parsing QuNet into more optimised graph structures via convertNet!()\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.BasicNode","page":"Home","title":"QuNet.BasicNode","text":"The default QNode object. Nothing special, but nothing unspecial either ;-)\"\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.CartCoords","page":"Home","title":"QuNet.CartCoords","text":"Coordinates of the QNode object in up to three spatial dimensions\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.CartNode","page":"Home","title":"QuNet.CartNode","text":"Similar to BasicNode, but with an extra parameter for cartesian spatial coordinates\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.CartSatNode","page":"Home","title":"QuNet.CartSatNode","text":"Satellite Node in Cartesian Coordinates\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.CartVelocity","page":"Home","title":"QuNet.CartVelocity","text":"Cartesian Velocity in up to 3 spatial coordinates\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.Costs","page":"Home","title":"QuNet.Costs","text":"Cost object for QNodes and QChannels\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.FibreChannel","page":"Home","title":"QuNet.FibreChannel","text":"Fibre optic channel, where the cost is determined by exponential loss in length\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.Pathset","page":"Home","title":"QuNet.Pathset","text":"Pathset is a collection of paths that all start at some vertex u and end at some vertex v. The purpose of the pathset is to organise / keep track of paths that are purified together.\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.PurifiedChannel","page":"Home","title":"QuNet.PurifiedChannel","text":"Channel class for multiple channels purified together\n\n\n\n\n\n","category":"type"},{"location":"#QuNet.E_to_dE-Tuple{Float64}","page":"Home","title":"QuNet.E_to_dE","text":"Convert from metric form to decibelic loss\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.F_to_dF-Tuple{Float64}","page":"Home","title":"QuNet.F_to_dF","text":"Convert from bell pair fidelity to decibelic form\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.GridNetwork-Tuple{Int64,Int64}","page":"Home","title":"QuNet.GridNetwork","text":"GridNetwork(dim::Int64, dimY::Int64)\n\nGenerates an X by Y grid network.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.addChannel!","page":"Home","title":"QuNet.addChannel!","text":"Add one or more channels to the network.\n\nTODO: Throw an error if src or dst not in the network\n\n\n\n\n\n","category":"function"},{"location":"#QuNet.addCostPrefix-Tuple{String}","page":"Home","title":"QuNet.addCostPrefix","text":"Add prefix \"CostΔ\" onto a cost name\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.addNode!-Tuple{QNetwork,Int64}","page":"Home","title":"QuNet.addNode!","text":"Add one or more nodes to the network.\n\nIf the node being initialised already exists in the network, (the IDs are equal) addNode replaces it. If node ID is greater than the number of nodes in the network, function warns user and sets node ID to nv + 1\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.addPurifyChannel-Tuple{MetaDiGraph,Pathset,Costs}","page":"Home","title":"QuNet.addPurifyChannel","text":"After purification, this function adds a channel between the src and dst with the purified costs and information about the Pathset.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.add_async_nodes!-Tuple{QuNet.TemporalGraph,Array{Tuple{Int64,Int64},1}}","page":"Home","title":"QuNet.add_async_nodes!","text":"Add asynchronus nodes to a Temporal Network.\n\nThis function adds tempnet.nv nodes to the graph. If a given node is source, outgoing asynchronus edges are added to the node that connects it to its temporal counterparts. This is done with incremental timeweights ϵ so that earlier times are prioritized.\n\nLikewise if a node is a dest, incoming asynchronus edges are added with incremental weights ϵ.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.airCosts-Tuple{QNode,QNode}","page":"Home","title":"QuNet.airCosts","text":"Calculate costs for AirChannel given length\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.ave_paths_used-Tuple{Array{Float64,1}}","page":"Home","title":"QuNet.ave_paths_used","text":"Given a tally for the number of paths used by each end-user in a greedy_protocol: (i.e. [3,4,2,1] meaning 3 end-users used no paths, 4, end-users used 1 path, etc.) This function finds the average number of paths used in the protocol.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.c_addQChannel-Tuple{MetaDiGraph,QChannel}","page":"Home","title":"QuNet.c_addQChannel","text":"Add a QChannel to the Network graph and return the vertex corresponding to the channel\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.c_addQNode!","page":"Home","title":"QuNet.c_addQNode!","text":"Add a QNode to the Network graph\n\n\n\n\n\n","category":"function"},{"location":"#QuNet.cartDistance-Tuple{QNode,QNode}","page":"Home","title":"QuNet.cartDistance","text":"Cartesian distance between two nodes\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.dE_to_E-Tuple{Float64}","page":"Home","title":"QuNet.dE_to_E","text":"Convert from decibelic loss to metric form\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.dF_to_F-Tuple{Float64}","page":"Home","title":"QuNet.dF_to_F","text":"Convert from decibelic bell pair fidelity to metric form\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.dict_average-Tuple{Any}","page":"Home","title":"QuNet.dict_average","text":"Return average average value for an array of cost vectors. If the length of the input is less than 1, mean is not well defined, the key values returned are 'nothing'.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.dict_err-Tuple{Any}","page":"Home","title":"QuNet.dict_err","text":"Return average standard error for an array of cost vectors. If the length of the input is less than 2, error is not well defined, the key values returned are 'nothing'.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.fibreCosts","page":"Home","title":"QuNet.fibreCosts","text":"Calculate costs for FibreChannel given length Length and attenuation parameter β have unspecified units.\n\n\n\n\n\n","category":"function"},{"location":"#QuNet.findPathInPathset-Tuple{Pathset,Union{Array{Tuple{Int64,Int64},1}, Array{LightGraphs.SimpleGraphs.SimpleEdge,1}}}","page":"Home","title":"QuNet.findPathInPathset","text":"If a path is in the pathset, return its index in the list. Else return 0.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.fix_async_nodes_in_time!-Tuple{QuNet.TemporalGraph,Array{Int64,1}}","page":"Home","title":"QuNet.fix_async_nodes_in_time!","text":"For a given node at time T in a TemporalGraph, this function fixes its asynchronus counterpart with respect to T This is done by removing all edges of the asynchronus node except for the one connecting at time T.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_addEdge!-Tuple{MetaGraphs.AbstractMetaGraph,Int64,Int64}","page":"Home","title":"QuNet.g_addEdge!","text":"Add an edge to the MetaDiGraph and instantiate the default properties from the edgeProps dictionary.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_addVertex!-Tuple{MetaGraphs.AbstractMetaGraph}","page":"Home","title":"QuNet.g_addVertex!","text":"Add a vertex to the MetaDiGraph and instantiate the default properties from the vertexProps dictionary.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_edgeCosts-Tuple{MetaDiGraph,Union{Tuple{Int64,Int64}, LightGraphs.SimpleGraphs.SimpleEdge{Int64}}}","page":"Home","title":"QuNet.g_edgeCosts","text":"Get the costs associated with an edge in the MetaDiGraph\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_getNode-Tuple{MetaDiGraph,Int64}","page":"Home","title":"QuNet.g_getNode","text":"Given a vertex in the graph, get the QNode corresponding to it. If the vertex does not correspond to a QNode, return 0. Else if the vertex doesn't exist in the network, return an error.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_getProp-Tuple{MetaGraphs.AbstractMetaGraph,String}","page":"Home","title":"QuNet.g_getProp","text":"Wrapper function for getting properties from meta graph.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_getVertex-Tuple{MetaDiGraph,Int64}","page":"Home","title":"QuNet.g_getVertex","text":"Given a QNode's id, get the vertex corresponding to it. If no vertex exists, return 0.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_pathCosts-Tuple{MetaDiGraph,Union{Array{Tuple{Int64,Int64},1}, Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}}}","page":"Home","title":"QuNet.g_pathCosts","text":"Given a path in the MetaDiGraph, return the associated costs\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_removeInactiveChannels!-Tuple{MetaDiGraph}","page":"Home","title":"QuNet.g_removeInactiveChannels!","text":"Remove the inactive channels of a graph\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_removeInactiveNodes-Tuple{MetaDiGraph}","page":"Home","title":"QuNet.g_removeInactiveNodes","text":"Remove the inactive Nodes of a graph\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.g_shortestPath-Tuple{MetaDiGraph,Int64,Int64,String}","page":"Home","title":"QuNet.g_shortestPath","text":"Find the shortest path in terms of the specified cost field. Returns the network path along with the associated costs.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.getChannel-Tuple{QNetwork,Int64,Int64}","page":"Home","title":"QuNet.getChannel","text":"Get the channel between src and dst. If no channel exists, return nothing\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.getChannelIdx-Tuple{QNetwork,Int64,Int64}","page":"Home","title":"QuNet.getChannelIdx","text":"Fetch the net.channel index of the channel between src and dst If no channel exists, returns nothing\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.getNode-Tuple{QNetwork,Int64}","page":"Home","title":"QuNet.getNode","text":"Get the node corresponding to the given id. If no node exists, returns nothing\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.greedyMultiPath!-Tuple{MetaDiGraph,Array{Tuple{Int64,Int64},N} where N}","page":"Home","title":"QuNet.greedyMultiPath!","text":"greedyMultiPath! is an entanglement routing strategy for multiple user-pairs in a quantum network.\n\nEach user pair has an associated Pathset that starts out empty. For each\n\nuserpair, the shortest path between them is found in terms of dF and the path is added to the pathset. If no path exists, nothing is added. This continues until one of the following criteria is met:     + The pathsets are filled with the threshold number of paths (given by maxpaths)\n\nEntanglement purification is performed over all the pathsets, removing the\n\npaths without adding purification channels.\n\nIf a pathset is empty, no path was found between the end-user pair.\nWhen all the bundles are filled up to the maximum number \"maxpaths\", use an\n\nentanglement purification method between the path costs. Add the resulting cost vector to the array purpaths. If no paths exist for a given bundle, increment the collision count by one, and add \"nothing\" to purpaths\n\nReturn the array of purified cost vectors and the collision count.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.greedy_multi_path!","page":"Home","title":"QuNet.greedy_multi_path!","text":"greedymultipath! is an entanglement routing strategy for a quantum network with n end user pairs.\n\nEach user pair has an associated \"bundle\" of paths that starts out empty.\n\nFor each user pair, find the shortest path between them, and add its cost to the bundle. If no path exists, add \"nothing\" to the bundle.\n\nWhen all the bundles are filled up to the maximum number \"maxpaths\", use an\n\nentanglement purification method between the path costs. Add the resulting cost vector to the array purpaths. If no paths exist for a given bundle, increment the collision count by one, and add \"nothing\" to purpaths\n\nReturn the array of purified cost vectors and the collision count.\n\n\n\n\n\n","category":"function"},{"location":"#QuNet.handleRepeatPurification-Tuple{MetaDiGraph,Pathset}","page":"Home","title":"QuNet.handleRepeatPurification","text":"Checks to see if an identical purification has already been done before so the purification channel isn't duplicated\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.heat_data-Tuple{Union{QNetwork, QuNet.TemporalGraph},Int64,Int64}","page":"Home","title":"QuNet.heat_data","text":"Takes a network as input and returns greedymultipath! heatmap data for some number of user pairs. (i.e. a list of efficiency fidelity coordinates for all end users over all num_trials)\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.make_user_pairs-Tuple{QuNet.TemporalGraph,Int64}","page":"Home","title":"QuNet.make_user_pairs","text":"Generate a list of end-users for a TemporalGraph. srclayer and dstlayer specify the temporal locations of the source and dst nodes respectively. The default value for these is -1, which indicates the end-users should be asynchronus.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.make_user_pairs_wbuffer-Tuple{QNetwork,Int64}","page":"Home","title":"QuNet.make_user_pairs_wbuffer","text":"Generate a list of user_pairs for a square grid network, ensuring that there is an edge buffer of a given thickness.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.mapNodeToVert!-Tuple{MetaDiGraph,Int64,Int64}","page":"Home","title":"QuNet.mapNodeToVert!","text":"Map a node in the QuNet to a vertex in the graph\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.max_timedepth-Tuple{Any,Any}","page":"Home","title":"QuNet.max_timedepth","text":"Find the maximum timedepth reached by a given pathset\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_channelCosts-Tuple{Any,Int64,Int64,Int64}","page":"Home","title":"QuNet.n_channelCosts","text":"Return the costs for a channel\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_getChannels-Tuple{MetaDiGraph,Int64,Int64}","page":"Home","title":"QuNet.n_getChannels","text":"Get a list of channel vertices between two nodes of the network. Return an empty list if no path is found.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_hasChannel","page":"Home","title":"QuNet.n_hasChannel","text":"Given the src and dst of a QChannel, determine if it exists in the MetaDiGraph\n\n\n\n\n\n","category":"function"},{"location":"#QuNet.n_hasNode-Tuple{MetaDiGraph,Int64}","page":"Home","title":"QuNet.n_hasNode","text":"Given a QNode, determine whether or not it exists in the MetaDiGraph\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_pathCapacity-Tuple{MetaDiGraph,Union{Array{Tuple{Int64,Int64},1}, Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}}}","page":"Home","title":"QuNet.n_pathCapacity","text":"Return the maximum capacity allowed by a given path\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_remAllChannels!","page":"Home","title":"QuNet.n_remAllChannels!","text":"Reduce the channel capacity associated with all channels connecting src and dst by one. If the channel capacity is zero, remove the channel.\n\n\n\n\n\n","category":"function"},{"location":"#QuNet.n_remChannel!-Tuple{MetaDiGraph,Int64}","page":"Home","title":"QuNet.n_remChannel!","text":"Reduce the channel capacity associated with an channel by one. If the channel capacity is zero, remove the corresponding edge. If the channel is undirected, operate on both directions.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_remNode-Tuple{MetaDiGraph,Int64}","page":"Home","title":"QuNet.n_remNode","text":"Remove a QNode from the graph and reindex the :nodeToVert map accordingly\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_remShortestPath!-Tuple{MetaDiGraph,Int64,Int64,String}","page":"Home","title":"QuNet.n_remShortestPath!","text":"Remove the shortest path in terms of the specified cost field. Returns the network path along with the associated costs.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_removeVertexPath!-Tuple{MetaDiGraph,Union{Array{Tuple{Int64,Int64},1}, Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}}}","page":"Home","title":"QuNet.n_removeVertexPath!","text":"Given a literal path in the MetaGraph, remove it from the network, taking care that channel bandwidth is reduced where applicable and making sure not to remove edges not corresponding to channels.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_setChannelCosts-Tuple{Any,Int64,Int64,Int64,Costs}","page":"Home","title":"QuNet.n_setChannelCosts","text":"Set the costs for a channel\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_shortestPath-Tuple{MetaDiGraph,Int64,Int64,String}","page":"Home","title":"QuNet.n_shortestPath","text":"Find the shortest path in terms of the specified cost field. Returns the network path along with the associated costs.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_uniqueChannel-Tuple{MetaDiGraph,Int64,Int64}","page":"Home","title":"QuNet.n_uniqueChannel","text":"Fetches the channel between srcNode and dstNode provided that one unique channel exists between them. If not, this function throws an error\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_uniqueVertexPath-Tuple{MetaDiGraph,Array{Tuple{Int64,Int64},1}}","page":"Home","title":"QuNet.n_uniqueVertexPath","text":"Returns a list of tuples representing a vertex path in the network provided that each channel is unique. If not, this function throws an error.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.n_vertexToNetPath-Tuple{MetaDiGraph,Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}}","page":"Home","title":"QuNet.n_vertexToNetPath","text":"Given a path in the MetaDiGraph, convert it to a path in the QNetwork\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.net_performance-Tuple{Union{QNetwork, QuNet.TemporalGraph},Int64,Int64}","page":"Home","title":"QuNet.net_performance","text":"Takes a network as input and return greedymultipath! performance statistics for some number of random user pairs. Ensure graph is refreshed before starting.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.node_timedepth-Tuple{Int64,Int64,Int64}","page":"Home","title":"QuNet.node_timedepth","text":"Get the temporal depth of a node from its index. If asynchronus, return -1 Throws an exception if the node is out of bounds.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.pathCosts-Tuple{QNetwork,Array{Tuple{Int64,Int64},1}}","page":"Home","title":"QuNet.pathCosts","text":"Get the costs of a path in the network.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.percolate_vertices-Tuple{LightGraphs.AbstractGraph,Any,Array{Int64,N} where N}","page":"Home","title":"QuNet.percolate_vertices","text":"percolate_vertices(graph, p, exclude)\n\nPerform vertex percolation on graph with probability p, excluding specified vertices.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.plotNetworkGraph-Tuple{MetaDiGraph}","page":"Home","title":"QuNet.plotNetworkGraph","text":"Plot the entire graph structure representing the quantum network\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.purify-Tuple{MetaDiGraph,Pathset}","page":"Home","title":"QuNet.purify","text":"Reduce the graph associated with the QuNetwork by performing a purification over a pathset\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.purifyCosts-Tuple{MetaDiGraph,Pathset}","page":"Home","title":"QuNet.purifyCosts","text":"Calculate the purification costs given a Pathset\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.relative_index-Tuple{Int64,Int64,Int64}","page":"Home","title":"QuNet.relative_index","text":"Get the relative index of a node from its original index. ie. for a graph with nv = 10, steps = 3, then node 14 is the same relative to node 4. Another way to think about this is that it gets the index of the corresponding node in the top layer.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.remChanVert-Tuple{MetaDiGraph,Any}","page":"Home","title":"QuNet.remChanVert","text":"Remove a vertex corresponding to a channel in the graph.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.remCostPrefix-Tuple{String}","page":"Home","title":"QuNet.remCostPrefix","text":"Strip prefix \"CostΔ\" from cost name\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.remPathset!-Tuple{MetaDiGraph,Pathset}","page":"Home","title":"QuNet.remPathset!","text":"Remove the pathset from the graph.\n\nIf the frequency of a path in the pathset exceeds the capacity of the path, this function sets the frequency to this maximum capacity and removes that amount of paths instead.\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.remove_async_nodes!-Tuple{QuNet.TemporalGraph}","page":"Home","title":"QuNet.remove_async_nodes!","text":"Remove all asynchronus nodes of a TemporalGraph.\n\ni.e. those put in place by addasyncnodes!\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.reversePathset-Tuple{Pathset}","page":"Home","title":"QuNet.reversePathset","text":"Make a reversed instance of a given Pathset\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.setChanAttrs-Tuple{Any,Any,Any}","page":"Home","title":"QuNet.setChanAttrs","text":"Set the attributes of a vertex corresponding to a qchannel. (Essentially all of the attributes of the qchannel except for the costs which go to the edges)\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.setEdgeCosts-NTuple{4,Any}","page":"Home","title":"QuNet.setEdgeCosts","text":"Set the costs of a directed edge corresponding to a qchannel. (Because there are two of these in every channel, the costs are set to half their usual value)\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.setVertexAttrs-Tuple{Any,Any,Any}","page":"Home","title":"QuNet.setVertexAttrs","text":"Set the attrtibutes of a vertex given a qnode and its index\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.temp_to_async-Tuple{Int64,Int64,Int64}","page":"Home","title":"QuNet.temp_to_async","text":"Convert temporal nodes into asynchronus nodes If the node is already asynchronus, it is returned Throws an exception if the node is out of bounds\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.tuplesToEdges-Tuple{Any}","page":"Home","title":"QuNet.tuplesToEdges","text":"Convert a path of tuples to a path of edges\n\n\n\n\n\n","category":"method"},{"location":"#QuNet.unpackStruct-Tuple{Any,Union{Int64, LightGraphs.SimpleGraphs.SimpleEdge},Any}","page":"Home","title":"QuNet.unpackStruct","text":"Unpack the attributes of a struct into attributes of a MetaDiGraph object\n\nProperties of a MetaGraph can be anything, including structs. Normally this wouldn't be an issue but setting the weights for methods like a_star with MetaGraphs.weightfield!() requires a single weight attribute to be set. This means that the fields of a struct like \"Costs\" need to be individually unpacked into the MetaGraph properties\n\nThe naming convention for unpacked attributes is identical to the 'dot notation' but replaced with right arrow (→).\n\nExample: struct Foo     bar end\n\nFoo.bar => :FooΔbar\n\nTODO: Make sure both channels are initialised.\n\n\n\n\n\n","category":"method"}]
}
